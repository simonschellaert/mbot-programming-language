<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Project Functioneel Programmeren</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.4/themes/prism.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.4/plugins/line-numbers/prism-line-numbers.css" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
$(document).ready(function() {
    $('.ebnf').html((i, old) => old.replace(/\|/g, '｜'))
             .html((_, old) => old.replace(/bar/g, '|'))
             .html(function (i, oldHtml) {
        return oldHtml.replace(/_([a-zA-Z0-9]*)_/g, (a, name) => "<span class='ebnf-class'>" + name + "</span>");
             }).html((_, old) => old.replace(/\*(\S*)\*/g, (a, name) => "<span class='ebnf-spacing'>" + name + "</span>"))
               .html((_, old) => old.replace(/(?!~)(\[|\]|{|}|｜|\(|\))(?!~)/g, (_, name) => "<span class='ebnf-syntax'>" + name + "</span>"))
               .html((_, old) => old.replace(/~(\S*)~/g, (_, id) => id));

               $('p').html((_, old) => old.replace(/([\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]|⏪|⬆️|⬇️|⬅️|➡️)/g, (_, emoji) => '<span class="emoji">' + emoji + '</span>'));

   // Include each of the files referenced with a `data-include-file` tag and then run syntax highlighting on the page
   $("[data-include-file]").each((_, el) => $(el).load($(el).attr('data-include-file'), null, () => Prism.highlightAll()));
});
</script>


<style>
@page  
{ 
    size: auto;   /* auto is the initial value */ 

    /* this affects the margin in the printer settings */ 
    margin: 25mm 25mm 25mm 25mm;  
} 



body {
    margin: 0px;
    font-size: 27px;
    font-family: "Garamond";
}

.ebnf {
    font-family: "Monaco", monospace;
    font-size: 18px;
    line-height: 40px;
}

.ebnf-class {
    border: 2px solid #ccc;
    border-radius: 7px;
    background-color: #f8f8f8;
    padding: 0 5px;
}

.ebnf-syntax {
    color: #888;
}

.ebnf-spacing {
    border: 2px solid #cbe0fe;
    border-radius: 7px;
    background-color: #cbe0fe;
    padding: 0 5px;
}


p {
    line-height: 1.3em;
    text-align: justify;
    margin-top: 0;
}

p .emoji {
    font-size: 0.8em;
    vertical-align: middle;
}


h1, h2, h3, h4, h5, h6 {
    font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
}

h1 {
    font-size: 1.4em;
}

h1 .emoji {
    font-size: 0.75em;
}

h2 {
    font-size: 1.2em;
}

h3 {
    margin-bottom: 0.3em;
}

h4 {
    margin-bottom: 0;
}

pre {
    font-size: 15px;
}

</style>
</head>

<body>

<h1>1. Introductie <span class="emoji">👋</span></h1>
<p>
    In het kader van het project voor functioneel programmeren, hebben we de taal 🤖 ontwikkeld.
    Deze taal kan gebruikt worden om een fysieke mBot of een virtuele mBot in de simulator, die we eveneens ontwikkelden, aan te sturen.
    Geïnspireerd door de overweldigende populariteit van Emoji, besloten we in de syntax veelvuldig gebruik te maken van Emoji.
    Een belangrijke drijfveer achter deze beslissing was het feit dat we programmaatjes er op die manier erg tof kunnen laten uitzien.
    Verder was het ook technisch een interessante uitdaging en leek het ons aangenaam om eens iets anders te schrijven dan de zoveelste <em>if..then..else</em>.
</p>

<p>
    Een belangrijk principe bij het ontwerp van onze taal was dat 🤖-programma's er steeds elegant en &lsquo;aaibaar&rsquo; moesten uitzien.
    Rekening houdend met dit principe, besloten we om onze taal niet louter uit Emoji op te bouwen, maar enkel Emoji te gebruiken waar dit een van de bovenstaande factoren verhoogde.
    Zo kozen we bijvoorbeeld voor 📏 in plaats <em>getDistance()</em>, maar kozen we niet voor ➗ in de plaats van / aangezien deze substitutie de leesbaarheid niet ten goede komt.
    Nog steeds met dit principe in het achterhoofd, probeerden we ook de &lsquo;clutter&rsquo; in onze taal zoveel mogelijk te beperken.
    Zo maken we net zoals Python gebruik van indentatie in plaats van paren haakjes om indentatie aan te duiden en worden statements gescheiden door een nieuwe lijn in plaats van een puntkomma.
    Aan de andere kant namen we het dubbelpunt na de conditie van een if-statement dan weer niet over, aangezien dit voornamelijk visuele ruis creërde.
</p>

<p>
    Uiteraard zijn we ons ervan bewust dat we niet de eerste zijn met dit idee.
    Er bestaan reeds andere programmeertalen die experimenteren met Emoji.
    Zo gebruikt de taal 4Lang louter Emoji, maar ook Apple's Swift laat Emoji-karakters toe in namen van variabelen of klassen.
    We besloten om ons zo weinig mogelijk te baseren op reeds bestaande implementaties omdat het ons leuker en leerrijker leek om iets volledig vanaf nul te bouwen.
</p>


<p>
    Los van het esthetische aspect, valt uiteraard wel te discussiëren over het praktisch nut van de taal. Zo bevatten de meeste toetsenborden geen Emoji-karakters.
    We zijn er dan ook geenszins van overtuigd dat een programmeertaal gebruik makend van Emoji effectief een goed idee is voor praktische toepassingen.
    Waar wel van overtuigd zijn, is das het ontwikkelen en implementeren van deze taal een erg interessante en aangename leerervaring was.
</p>

<h1>2. Syntax van de taal <span class="emoji">✒️</span></h1>
<p>
We maken gebruik van de <em>Extended Backus-Naur form</em> om de syntax van onze taal te beschrijven.
Om dit overzichtelijk te houden, voegen we wat extra opmaak toe om duidelijk het onderscheid te maken tussen elementen in onze taal en elementen van EBNF.
Zo worden niet-terminalen <span class="ebnf-class">omkaderd</span> en krijgen symbolen die witruimte aanduiden een <span class="ebnf-spacing">blauwe achtergrond</span>.
Syntaxelementen van EBNF worden vervolgens aangeduid met een <span class="ebnf-syntax">lichte kleur</span>.
Alle terminalen die de gebruiker effectief intypt (bv. haakjes of 👍), zijn tenslotte een emoji of gewoon zwart.
</p>

<pre class="ebnf">
_StmtSeq_    := _Stmt_ { *⏎* _Stmt_ }
_Stmt_       := _Assignment_ | _While_ | _If_ | _Command_ | _Skip_

_Assignment_ := <em>Identifier</em> ⏪ _AExp_
_While_      := 🔁 _BExp_ *⇥* _StmtSeq_ *⇤*
_If_         := ❓ _BExp_ *⇥* _StmtSeq_ *⇤* { *⏎* ⁉️ _BExp_ *⇥* _StmtSeq_ *⇤* } [ *⏎* ❗️ *⇥* _StmtSeq_ *⇤* ]
_Skip_       := 💭 <em>Some text</em>

_AExp_       := _ATerm_ { ( + | - ) _ATerm_ }
_ATerm_      := _AFactor_ { ( * | / ) _AFactor_ }
_AFactor_    := ~(~_AExp_~)~ | _Constant_ | _Sensor_ | <em>Identifier</em>
_Constant_   := <em>Literal</em> | 🌑 | 🌓 | 🌗 | 🌕
_Sensor_     := 📏 | 🔭

_BExp_       := _BTerm_ { barbar _BTerm_ }
_BTerm_      := _BFactor_ { && _BFactor_ }
_BFactor_    :=  👍  | 👎 | ! _BFactor_ | ~(~_BExp_~)~ |  _BRel_
_BRel_       := _AExp_ < _AExp_ | _AExp_ == _AExp_ | _AExp_ > _AExp_

_Command_    := 💨 _Direction_ | 😴 _Duration_ | 🚨 _Flank_ _AExp_ _AExp_ _AExp_ | 🎶 _Duration_ _AExp_
_Direction_  := ⬇️ | ➡️ | ⬅️ | ⬆️
_Duration_   := 🕑 | 🕔 | 🕖 | 🕙 | _AExp_
_Flank_      := 👈 | 👉
</pre>

<p>
In bovenstaande definities duidt <em>Identifier</em> de naam van een variabele aan.
Variabelenamen beginnen steeds met een letter gevolgd door nul of meerdere alfanumerieke karakters.
Een <em>Literal</em> is een geheel getal in het decimale talstelsel.
<em>Some text</em> duidt vervolgens één regel tekst met eender welke karakters, ook witruimte, aan.

<h1>3. Semantiek van de taal <span class="emoji">📜</span></h1>
<p>
    Een programma in 🤖 is een <span class="ebnf-class">StmtSeq</span>, m.a.w. een opeenvolging van statements die elk op een eigen lijn staan.
    We maken dus geen gebruik van puntkomma's om statements te scheiden, zoals dat vaak gebeurt, maar wel van één of meerdere newline-karakters.
    Ook worden blokken niet aangeduid door ze te omringen met overeenkomstige haakjes, maar wel door de statements die deel uitmaken van het blok meer te laten inspringen.
    Verder zijn de statements die we onderscheiden erg gelijkaardig aan diegene die je vindt in traditionele imperatieve programmeertalen. De vijf types statements worden hieronder individueel toegelicht.
</p>

<h3>Assignment</h3>
<p>
Dit is een toekenning. De waarde van de aritmetische expressie rechts van het toekenningsteken (⏪) wordt opgeslagen onder de naam <em>Identifier</em>, die links die van het toekenningsteken staat.
</p>

<h3>While</h3>
<p>
    Dit is een lus. De body wordt uitgevoerd zolang de booleaanse expressie die de conditie voorstelt naar 👍 evalueert.
</p>

<h3>If</h3>
<p>
    Dit is een conditional. De structuur is hetzelfde als bij een traditioneel if/else-if/else-statement.
    Eerst wordt de booleaanse expressie naast ❓ geëvalueerd, als deze naar 👍 evalueert wordt de bijhorende body uitgevoerd.
    Indien de conditie naar 👎 evalueert, testen we de ⁉️-condities één voor één en voeren we de body uit die hoort bij de eerste die naar 👍 evalueerde. Indien geen enkele conditie naar 👍 evalueerde, wordt de body van ❗️-tak uitgevoerd indien deze gegeven is.
    Er mogen dus een nul of meerdere ⁉️-takken zijn en hoogstens één ❗️-tak.
</p>

<h3>Skip</h3>
<p>
    Dit is commentaar. Alle tekst rechts van de 💭 wordt genegeerd.
</p>

<h3>Command</h3>
<p>
    Dit stelt een commando voor dat naar de MBot of de simulator wordt gestuurd.
    Er zijn vier types commando's. De argumenten van een commando worden van elkaar gescheiden door een spatie.
</p>

<h4>Drive</h4>
<p>
    Stel de motor in om in de opgegeven richting te rijden.
    Mogelijke richtingen zijn vooruit (⬆️), achteruit, (⬇️), naar links (⬅️) en naar rechts (➡️).
</p>

<h4>Sleep</h4>
<p>
    Slaap even alvorens verder te gaan met de uitvoering.
    Gedurende het slapen, blijft de MBot actief. Hij rijdt m.a.w. verder in de richting waarin hij aan het rijden was.
    Als argument kan een arithmetische expressie, die het aantal te slapen milliseconden voorstelt, meegegeven worden.
    Een andere mogelijkheid is om gebruik te maken van één van de ingebouwde constanten om 100 ms(🕑), 250 ms (🕔), 500 ms (🕖) of 1 s (🕙) te slapen. 
</p>

<h4>Light</h4>
<p>
    Laat het opgegeven lichtje branden in de opgegeven kleur.
    Het eerste argument duidt aan als het commando betrekking heeft op het linkse (👈) of rechtse (👉) lichtje.
    De volgende drie argumenten zijn aritmetische expressies die de RGB-waarde van het in te stellen kleur voorstellen.
    Het bereik van de RGB-waarden loopt van 0 t.e.m. 100 en waarden buiten dit interval worden geclipped.
</p>

<h4>Sound</h4>
<p>
    Speel de opgegeven toon af voor de opgegeven duur.
    Het eerste argument stelt de duur voor die we de toon willen afspelen. Net zoals bij het sleep-commando, kunnen we hier een arithmetische expressie of een ingebouwde constante meegeven.
    Het tweede argument is vervolgens een arithmetische expressie die de frequentie voorstelt.
</p>

<p>
    In de bovenstaande bespreking van statements, werden de termen <em>booleanse expressie</em> en <em>arithmetische expressie</em> veelvuldig gebruikt.
    We leggen nu ook de semantiek van deze taalelementen precies vast.
</p>

<h3>Arithmetische expressies</h3>
<p>
    Een arithmetische expressie is een uitdrukking die als resultaat een geheel getal oplevert.
    Om de prioriteit van de bewerkingen eenduidig vast te leggen, gebruiken we een hiërarchie van taalelementen.
    Een expressie bestaat uit één of meerdere termen gescheiden door een plus- of min-symbool
    Deze twee operatoren zijn links-associatief en hebben de laagste prioriteit.
    Een term bestaat vervolgens uit één of meerdere factoren gescheiden door een maal- of deling-symbool, welke ook beide links-associatief zijn.
    Een factor tenslotte is het meest elementaire deel en kan bestaat uit een expressie omringd door haakjes, een constante een sensor of een identifier.<br />
</p>

<p>
    Een constante is ofwel de decimale representatie van een geheel getal of één van de ingebouwde constanten - 🌑, 🌓, 🌗 en 🌕 - die respectievelijk 0, 1, 2 en 3 voorstellen.
    (Denk aan de binaire voorstelling van deze getallen om in te zien waarom deze representatie steek houdt).
</p>

<p>
    Een sensor verwijst naar de sensorwaarde van een van de ingebouwde sensoren.
    De afstandssensor, 📏, stelt de afstand voor tot het object voor de mBot.
    De waarde van deze sensor is steeds een geheel getal.
    De lijnsensor, 🔭, geeft aan welke kleur de mBot onder zich ziet.
    De waarde van deze sensor is steeds één van de getallen 🌑 (beide zwart), 🌓 (enkel links zwart), 🌗 (enkel rechts zwart) en 🌕 (beide wit).
</p>

<p>
    Een identifier verwijst vervolgens naar de waarde van een variabele.
    Indien er nog niet eerder geschreven werd naar de corresponderende variabele, wordt er een fout opgegooid tijdens de uitvoering.
</p>

<h3>Booleaanse expressies</h3>
<p>
    Een booleaanse expressie is een uitdrukking die als resultaat de waarde waar (👍) of onwaar (👎) oplevert.
    Om de prioriteit van de bewerkingen ook hier eenduidig vast te leggen, gebruiken we opnieuw een hiërarchie van taalelementen.
    Een expressie bestaat uit één of meerdere termen gescheiden door het OR-symbool (||).
    Een term bestaat uit zijn beurt weer uit één of meerdere factoren gescheiden door het AND-symbool (&and;&and;).
    Een factor tenslotte is waar (👍), onwaar (👎), het omgekeerde van factor, een expressie tussen haakjes of een relatie.
</p>

<p>
    Een relatie is een vergelijking tussen twee arithmetische expressies en levert een booleanse waarde op die de uitkomst van de vergelijking voorstelt.
    Hier zijn de relaties kleiner dan (<), gelijk aan (==) en groter dan (>) geïmplementeerd.
</p>

<h1>4. Voorbeeldprogramma's <span class="emoji">📚</span></h1>
<h2>Politiewagen</h2>
<pre><code class="language-markup line-numbers" data-include-file="/examples/police.txt"></code></pre>

<h2>Lijn volgen</h2>
<pre><code class="language-markup line-numbers" data-include-file="/examples/linefollower.txt"></code></pre>

<h2>Obstakels ontwijken</h2>
<pre><code class="language-markup line-numbers" data-include-file="/examples/obstacles.txt"></code></pre>

<h1>5. Implementatie <span class="emoji">👨‍💻</span></h1>
<h2>Preprocessor</h2>
<p>
Doordat onze taal i.p.v. paren van overeenkomstige haakjes gebruikt maakt van indentatie (de zgn. off-side rule) om blokken aan te duiden, is de taal niet langer context-vrij.
Het parsen van een niet-contextvrije taal kan echter snel relatief ingewikkeld worden. Gelukkig bestaat er een elegant trukje, dat onder andere door parsers voor Python wordt gebruikt, om alsnog een contextvrije taal te bekomen.
Het trukje bestaat eruit om onze taal eerst te laten verwerken door een preprocessor die telkens een <code>INDENT</code> token toevoegt als de indentatie vermeerdert en een <code>DEDENT</code> token als deze vermindert.
Deze preprocessor houdt dan toestand bij, zijnde een stack van voorgaande indentatieniveaus, maar we bekomen vervolgens een nieuwe taal die wel contextvrij is.
Deze nieuwe taal, met als enige verschil dat alle indentatie vervangen is door <code>INDENT</code>/<code>DEDENT</code> tokens, wordt vervolgens verwerkt door de parser, die geen rekening meer hoeft te houden met indentatie.



</p>

<h1>6. Conclusie <span class="emoji">🏁</span></h1>


<h1>7. Broncode <span class="emoji">🎼</span></h1>

<pre><code class="language-haskell line-numbers" data-include-file="/Parser.hs"></code>
</pre>



<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.4/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.4/components/prism-haskell.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.4/plugins/line-numbers/prism-line-numbers.js"></script>
</body>

</html>
